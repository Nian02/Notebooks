## 接口简介

有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，**Java 不支持多重继承**。有了接口，就可以得到多重继承的效果。

或者说，仅仅只是从几个类中抽取出一些共同特征，例如：鼠标、键盘、打 印机、扫描仪、摄像头、充电器、MP3、手机、数码相机、移动硬盘等都支持USB接口连接。

![](../../../Image/Java/Java%20接口示例.png)

**接口就是规范，定义的是一组规则**，接口是一种“能力”，而继承是一种“共性”

-  继承是一个"是不是"的 `is-a` 关系（所有的动物都会吃饭、喝水，因此将这些定义在父类当中）
-  接口是 "能不能"的 `has-a` 关系（只有少部分的动物会游泳，因此将游泳定义在父类外的接口中）

## 类与接口

接口的定义，和定义类的语法类似，但是使用的是 `interface` 关键字。它也会编译成 `.class` 文件，但是一定要明确的是它不是类，而是另外一种引用数据类型。而且接口和抽象类是两种完全不同的概念，可以将抽象类比作喝水的不同方式（共性），接口比作游泳（能力）

>引用数据类型：数组、类、接口。

-  类与类的关系：**继承**关系，只能单继承不能多继承，可以多层继承
-  类与接口的关系：**实现**关系，可以单实现也可以多实现（要把所有抽象方法重写），还可以在继承一个类的同时实现多个接口
-  接口与接口的关系：**继承**关系，可以单继承也可以多继承

```java
权限修饰符 interface 接口名 {
    // 接口的成员列表：
    // 静态常量
    // 抽象方法
    // 默认方法
    // 静态方法
    // 私有方法
}
```

例：
```java
public interface Fly {
    void fly();// 抽象方法
}
```

```java
// 都具备fly的能力
public class Bird implements Fly {
    @Override
    public void fly() {
        System.out.println("小鸟在飞");
    }
}

public class SuperMan implements Fly {
    @Override
    public void fly() {
        System.out.println("超人在飞");
    }
```

## 接口中的成员说明

接口定义的是多个类共同的公共行为规范，这些行为规范是和外部交流的通道，这就意味着接口里通常定义一组公共方法。

-  在 JDK8 之前，接口中只允许出现
	-  公共的静态常量：其中 `public static final` 可以省略
	-  公共的抽象方法：其中 `public abstract` 可以省略

>接口是从多个相似类中抽象出来的规范，不需要提供具体实现

-  在 JDK8 时，接口中允许声明默认方法和静态方法
	-  公共的默认方法：其中 `public` 可以省略，但是建议保留，但是 `default` 不能省略
	-  公共的静态方法：其中 `public` 可以省略，但是建议保留，但是 `static` 不能省略
-  在 JDK9 的时候，接口允许私有方法

>目前而言，接口中除了**静态常量、抽象方法、默认方法、静态方法、私有方法**外，接口中不能有其他成员（**构造器**、初始化块）

### 公共的静态常量

接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范的时候，不能随意的去修改和触碰这些底线边界值。比如USB3.0 规范中规定最大传输速率是5Gbps (500MB/s) ，最大输出电流是 5V/900 mA。

### 公共的抽象方法

接口是代表行为标准，它只规定方法的方法头（只有方法头的方法也叫抽象方法）方法头也就是方法签名已经提供了功能的描述信息，调用者无需关注具体的方法实现细节。

### 公共的静态方法

在之前的标准类库设计中，有很多 Collection/Collections 、Path/Paths 这样的成对的接口和类，后面的类中都是静态方法，而这样**静态方法都是为了前面的接口服务的**，那么在设计这样一对 API 的时候，还不如将静态方法直接定义到接口中，这样使用和维护更为方便。

在接口中的静态方法只能通过接口名调用

### 公共的默认方法

如果在接口中**添加抽象方法**，就会涉及到原来使用这些接口的**实现类都需要重写抽象方法**，为了保持和旧版本的代码的**兼容性**，只能允许接口中定义**默认方法**，比如：JDK8 中对 Collection 、List 、Comparator 等接口都提供了丰富的默认方法。

当我们接口中的某个抽象方法，在很多类中的实现代码都是一样的，那么此时就可以将这个抽象方法设计为默认方法更为合适，那么实现类可以选择重写，也可以选择不重写。

### 私有方法

有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由相同的代码抽取，而这些相同的代码抽取出来的代码又希望只在接口内部使用，所以增加了私有方法。


