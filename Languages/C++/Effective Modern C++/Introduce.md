### 左值、右值
移动语义的基础是区分右值和左值表达式。那是因为右值表明这个对象适合移动操作，而左值一般不适合。

对于判断一个表达式是否是左值的一个有用的启发就是，看看能否取得它的地址。如果能取地址，那么通常就是左值。如果不能，则通常是右值。
- 右值对应于从函数返回的临时对象
- 左值对应于你可以引用的（can refer to）对象

>一个表达式的类型与它是左值还是右值无关，形参本身是个左值，其类型可以是右值，比如：
```C++
class Widget {
public:
    Widget(Widget&& rhs);   //rhs是个左值，
    …                       //尽管它有个右值引用的类型
};
```
- 类的名字是`Widget`。每当我想指代任意的用户定义的类型时，我用`Widget`来代表。
- 形参名`rhs`（“right-hand side”）。这是我喜欢的**移动操作**（即移动构造函数和移动赋值运算符）和**拷贝操作**（拷贝构造函数和拷贝赋值运算符）的形参名。

### 拷贝构造、移动构造
```C++
void someFunc(Widget w);        //someFunc的形参w是传值过来
Widget wid;                     //wid是个Widget
someFunc(wid);                  //在这个someFunc调用中，w是通过拷贝构造函数
                                //创建的副本
someFunc(std::move(wid));       //在这个someFunc调用中，w是通过移动构造函数
                                //创建的副本
```
右值副本通常由移动构造产生，左值副本通常由拷贝构造产生。

### 实参、形参
在函数调用中，调用地传入的表达式称为函数的**实参**（_argument_）。实参被用来初始化函数的**形参**（_parameter_）。在上面第一次调用`someFunc`中，实参为`wid`。在第二次调用中，实参是`std::move(wid)`。两个调用中，形参都是`w`。

实参和形参的区别非常重要，因为**形参是左值**，而用来初始化形参的**实参可能是左值或者右值**。这一点尤其与**完美转发**（_perfect forwarding_）过程有关，被传给函数的实参以原实参的右值性（_rvalueness_）或左值性（_lvalueness_），再被传给第二个函数。

### 异常安全
设计优良的函数是**异常安全**（_exception safe_）的，意味着他们至少提供基本的异常安全保证（即基本保证 _basic guarantee_ ）。这样的函数保证调用者在异常抛出时，程序的变量保持完整（即没有数据结构是毁坏的），且没有资源泄漏。有强异常安全保证的函数确保调用者在异常产生时，程序保持在调用前的状态。

### 函数对象
当我提到“**函数对象**”时，我通常指的是某个支持`operator()`成员函数的类型的对象。换句话说，这个对象的行为像函数一样。偶尔我用稍微更普遍一些的术语，表示可以用**非成员函数语法调用**的任何东西（即“`fuctionName(arguments)`”）。

这个广泛定义包括的不仅有支持`operator()`的对象，还有函数和类似C的函数指针。（较窄的定义来自于C++98，广泛点的定义来自于C++11。）将成员函数指针加进来的更深的普遍化产生了我们所知的**可调用对象**（_callable objects_）。你通常可以忽略其中的微小区别，简单地认为函数对象和可调用对象为C++中可以用函数调用语法调用的东西。

### 闭包
通过 _lambda_ 表达式创建的函数对象称为**闭包**（_closures_）。没什么必要去区别 _lambda_ 表达式和它们创建的闭包，所以我经常把它们统称 _lambdas_ 。类似地，我几乎不区分**函数模板**（_function templates_）（即产生函数的模板）和**模板函数**（_template functions_）（即从函数模板产生的函数）。**类模板**（_class templates_）和**模板类**（_template classes_）同上。

### 声明、定义
C++中的许多东西都可被声明和定义。**声明**（_declarations_）引入名字和类型，并不给出比如存放在哪或者怎样实现等的细节：
```C++
extern int x;                       //对象声明
class Widget;                       //类声明
bool func(const Widget& w);         //函数声明
enum class Color;                   //限域enum声明（见item 10）
```

>我定义一个函数的**签名**（_signature_）为它声明的一部分，这个声明指定了**形参类型和返回类型**。函数名和形参名不是签名的一部分。在上面的例子中，`func`的签名是`bool(const Widget&)`。

**定义**（_definitions_）提供存储位置或者实现细节：
```C++
int x;                              //对象定义
class Widget {                      //类定义
    …
};
bool func(const Widget& w)
{ return w.size() < 10; }           //函数定义
enum class Color
{ Yellow, Red, Blue };              //限域enum定义
```

### 未定义的行为
有时标准说一个操作的结果有**未定义的行为**（_undefined behavior_）。这意味着运行时表现是不可预测的，不用说你也想避开这种不确定性。有未定义行为的行动的例子是：
- 在`std::vector`范围外使用方括号（“`[]`”），解引用未初始化的迭代器。
- 引入数据竞争（即有两个或以上线程，至少一个是writer，同时访问相同的内存位置）。

### 智能指针
我将那些比如从`new`返回的内置指针（_build-in pointers_）称为**原始指针**（_raw pointers_）。原始指针的“反义词”是**智能指针**（_smart pointers_）。智能指针通常重载指针解引用运算符（`operator->`和`operator*`）。