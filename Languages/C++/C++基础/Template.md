# 模板
模板是对具有相同特性的函数或类的再抽象，模板是一种参数多态性的工具，可以为逻辑功能相同而类型不同的程序提供一种**代码共享**的机制。 一个模板并非一个实实在在的函数或类，仅仅是一个函数或类的描述，是参数化的函数和类。

## 函数模板
```C++
template <class T1, class T2,…>返回类型 函数名(参数表){
   	…… 								//函数模板定义体
}
```

### 模板参数
- `T1, T2 ,…`是**模板参数**，其中的class表示其后的参数可以是任意类型。在模板实例化（即调用模板函数时）时需要传递的实参是一种数据类型，如int或double之类。 

- 函数模板可以有多个类型参数，但每个类型参数都必须用关键字class或typename限定。此外，模板参数中还可以出现确定类型参数，称为**非类型参数**。
```C++
template <class T1,class T2,class T3,int T4>
T1 fx(T1 a, T2 b, T3 c){…}
```

### 注意事项
 - 在定义模板时，不允许template语句与函数模板定义之间有任何其他语句。
```C++
template <class T>
int x;                 //错误，不允许在此位置有任何语句
T min(T a,T b){…}
```

- 不要把这里的class与类的声明关键字class混淆在一起，虽然它们由相同的字母组成，但含义是不同的。这里的class表示T是一个类型参数，可以是**任何数据类型**，如int、float、char等，或者用户定义的struct、enum或class等自定义数据类型。
>为了区别类与模板参数中的类型关键字class，标准C++提出了用typename作为模板参数的类型关键字，同时也支持使用class。比如，把min定义的template 写成下面的形式是完全等价的：
```C++
template <typename T> 
T min(T a,T b){…}
```

### 函数模板的实例化
-   **实例化发生的时机：模板实例化发生在调用模板函数时**。当编译器遇到程序中对函数模板的调用时，它才会根据调用语句中**实参的具体类型，确定模板参数的数据类型**，并用此类型替换函数模板中的模板参数，生成能够处理该类型的函数代码，即模板函数。
-   当多次发生类型相同的参数调用时，只在第1次进行实例化。假设有下面的函数调用：
```C++
int x=min(2,3);     
int y=min(3,9);
int z=min(8.5);
```
编译器只在第1次调用时生成模板函数，当之后遇到相同类型的参数调用时，不再生成其他模板函数，它将调用**第1次实例化生成的模板函数**。

### 实例化的方式
- **隐式实例化**
编译器能够判断**模板参数类型**时，自动**实例化函数模板为模板函数**。
```C++
template <typename T> T max (T, T);
…
int i = max (1, 2); 
float f = max (1.0, 2.0);
char ch = max (‘a’, ‘A’);
…
```
>隐式实例化，表面上是在调用模板，实际上是调用其实例

- **显式实例化**
需要使用特定数据类型实例化，语法形式：`模板名称<数据类型,…,常量值,…> (参数)`
```C++
template <class T> T max (T, T);
…
int i = max (1, ‘2’); 
// error: data type can’t be deduced
int i = max<int> (1, ‘2’);
…
```

## 类模板
类模板可用来设计结构和成员函数完全相同，但所处理的数据类型不同的通用类。
```C++
// 双精度栈
class doubleStack{
    private:
    double data[size];
    ……
};
// 字符栈
class charStack{
    private:
    char data[size];
    ……
};
```

### 类模板的声明
类模板也可以使用类型参数和非类型参数
```C++
template<class T1,class T2,…>
class 类名{
    	……								// 类成员的声明与定义
}
```

### 类模板的成员函数的定义
语法 `template <模板参数列表> T返回值类型 类模板名<模板参数名表>::成员函数名 (参数列表)T{T ……T};`
可以实现类模板的成员函数的特化：
```C++
template<>  void Array<char *>::Sort(){
    for(int i=0;i<Size-1;i++){
        int p=i;
        for(int j=i+1;j<Size;j++)
            if(strcmp(a[p],a[j])<0)
                p=j;
        char* t=a[p];
        a[p]=a[i];
        a[i]=t;
    }
}
```